## cache-aside-pattern
这个缓存边缘策略，是一个处理缓存与数据库一致性矛盾的策略思想。
cache与DB，无非是以下几个可能性：
* 先操作DB，再操作Cache
* 先操作Cache，再操作DB
* 操作Cache时是更新Cache
* 操作Cache时是删除Cache

微软文档针对这个`cache-aside-pattern`策略给出的答案是`先更新DB再删除Cache`，代码如下：
```
public async Task UpdateEntityAsync(MyEntity entity)
{
    // Update the object in the original data store.
    await this.store.UpdateEntityAsync(entity).ConfigureAwait(false);

    // Invalidate the current cache object.
    var cache = Connection.GetDatabase();
    var id = entity.Id;
    var key = $"MyEntity:{id}"; // The key for the cached object.
    await cache.KeyDeleteAsync(key).ConfigureAwait(false); // Delete this key from the cache.
}
```
操作Cache时，`不会更新`而是`直接删除`的原因：
```
lazy load，减少无用的操作，提高系统性能
```
`Cache-aside-pattern`先更新DB再删除Cache的原因：
```
The order of the steps is important. 
Update the data store before removing the item from the cache. 
If you remove the cached item first, there is a small window of time when a client might fetch the item before the data store is updated. 
That will result in a cache miss (because the item was removed from the cache), causing the earlier version of the item to be fetched from the data store and added back into the cache. 
The result will be stale cache data.
```
翻译下就是：
```
如果先删除Cache再更新DB，有个空窗时间，这个时间段中如果有查询过来，会更新旧数据到Cache进而引发Cache与DB不一致。
```
我本人的疑惑：
```
如果先更新DB再删除Cache，DB更新完毕，但是通知Cache删除的时候失败，也会导致两边数据不一致，怎么办？
```
本人自己的回答：
```
1、没有绝对完美的答案，很多设计都是取舍；
2、上面的先删除Cache再更新DB 和 先更新DB再删除Cache，有个核心问题，就是概率，你觉得操作redis失败的概率高还是遇到读写并发的概率高？
3、人家微软、facebook都是用cache-aside-pattern，并不是没有道理的，经得起考验。
4、58同城用的是先更新DB再删除Cache，理由就是redis操作可能会失败，这点我不认可。
```
这个`cache-aside-pattern`绝对没有并发问题吗？
```
1、目前没有Cache，读操作需要去DB拉取数据后更新到Cache中（此时的数据版本V1）；
2、此时此刻来一个写操作，它更新完DB后（此时的数据版本V2），把Cache删除；
3、步骤2比步骤1执行更快，所以不会影响步骤1的Cache写入；
4、所以最后Cache的数据是V1,DB的数据是V2，数据不一致。
```
可能会遇到数据不一致的情况，但概率太低了：
```
1、刚好要遇到缓存失效的情况；
2、必须先来一个读操作，再来一个写操作，但是写操作一般是耗时远大于读操作的，结果你还要求人家学操作先执行完毕；
```

* [不同类型的页](#不同类型的页)
* [数据页总览](#数据页总览)
* [Page Directory 页目录](#page-directory-页目录)
  * [槽](#槽)
  * [数据分组](#数据分组)
  * [一个组有多少条记录呢](#一个组有多少条记录呢)
  * [为啥是组内的最后一条，而不会第一条或者别的](#为啥是组内的最后一条而不会第一条或者别的)
* [Page Header](#page-header)
* [File Header](#file-header)
* [File Trailer](#file-trailer)

# 不同类型的页
* 表空间头部的页
* 存放 insert buffer 的页
* 存放 INODE 的页
* 存放 undo 的页
* 存放行记录的数据页，官方叫索引页

# 数据页总览
关键词：
* 一页16KB
* 只要是个页，肯定有页头和页尾：File Header 和 File Trailer
* 数据页：有一个专属的 Page Header

看看数据库的结构图：
![InnoDB数据页结构示意图.png](../imgs/mysql/InnoDB数据页结构示意图.png?raw=true)
* File Header（每个页都有的 header）
* Page Header（数据页特有的 header）
* 最小记录 infimum 与最大记录 supremum，固定大小，26 字节(为啥不是25字节呢？)
* 用户记录
* Free Space（插入记录时，可以从此处申请空间，换言之此空间会不断减少）
* Page Directory（用户记录分组槽位）
* File Trailer（每个页也都有的尾巴）

# Page Directory 页目录
## 槽
* 组内的最后一条记录的地址偏移量，称之为槽
* 逆序（原因从 Fire Trailer 逆序过来拿比较顺手）
* 页目录里面放着一个个槽

## 数据分组
* 最小记录 infimum 单独一组
* 最大记录 supremum 的那一组最多 1-8 个记录
* 其他组的记录数 4-8

## 一个组有多少条记录呢
* 组内的最后一条记录的【记录的额外信息】中的【记录头信息】 里面有个字段 n_owned，表示该组多少个记录

## 为啥是组内的最后一条，而不会第一条或者别的
* 因为记录是按照主键大小从小到大类似链表串联，最后一条是组内的最大记录
* 用最大记录有 2 个好处
    * 2 分搜索记录是一个好边界（所以就只能组内头尾两个记录中来选择）
    * page directory的槽放的就是这条记录的偏移地址（为啥不能放组内头部的那条呢，一样快速跳转啊）

总结：所以我个人感觉，用组内第一个记录来做统筹者也是可以的，只是刚好选择了尾部的那个而已，求大神打脸！


# Page Header

如果是我来设计，数据页的一个 page header 肯定要放一些总览信息如：
* 槽数量：数组分组的多少个？ 
* 记录数量：一共有多少个记录？
* 删除的记录数量： 一共删了多少个记录？
* 空闲空间的起点：Free Space 是不断被榨干的一个空间，我们要立马获取到可插入记录的地址
* 删除的第一条记录：因为按照 innodb 的尿性，肯定是也是有一条删除记录的链表，所以我只要记录第一条被删除的记录地址即可

我们看看正确答案猜中了多少：

|竞猜结果|名称	|占用空间大小	|描述|
|:----|:---- | ---- | :-----|
|猜中了，肯定有槽的数量，肯定想知道一个页有多少个数据分组|PAGE_N_DIR_SLOTS|	2字节|	在页目录中的槽数量|
|猜中了，因为每次 insert 记录，都是从 Free Space 申请得来|PAGE_HEAP_TOP|	2字节	|还未使用的空间最小地址，也就是说从该地址之后就是Free Space|
|猜中了，一页有多少条记录数你不关心？|PAGE_N_HEAP|	2字节|	本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |    
|猜中了，innodb肯定想组建一条删除记录链表，以备重复利用！|PAGE_FREE|	2字节|	第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）|
|猜中 9 成，我猜的是已删除记录的个数，而不是字节数|PAGE_GARBAGE	|2字节	|已删除记录占用的字节数|
|没想到，不过知道最后的插入位置也正常。因为不可能时时刻刻从 free space 申请，要是我就申请一大批，慢慢用。|PAGE_LAST_INSERT|	2字节	|最后插入记录的位置|
|没想到，要方向作甚？|PAGE_DIRECTION|	2字节	|记录插入的方向|
|没想到，要该方向连续了多少次作甚？|PAGE_N_DIRECTION	|2字节	|一个方向连续插入的记录数量|
|没想到，但是确实应该知道纯洁的记录数！不包括已删除的和最大最小 2 条。|PAGE_N_RECS|	2字节	|该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）|
|没想到，这是啥？|PAGE_MAX_TRX_ID|	8字节|	修改当前页的最大事务ID，该值仅在二级索引中定义|
|没想到，不过B+树确实应该知道在第几层，嗯！|PAGE_LEVEL|	2字节|	当前页在B+树中所处的层级|
|没想到，不过每棵B+树都是一个索引树，肯定是属于某一个索引，比如主键？比如二级？|PAGE_INDEX_ID|	8字节	|索引ID，表示当前页属于哪个索引|
|没想到，这是啥？|PAGE_BTR_SEG_LEAF|	10字节|	B+树叶子段的头部信息，仅在B+树的Root页定义|
|没想到，这是啥？|PAGE_BTR_SEG_TOP|	10字节|	B+树非叶子段的头部信息，仅在B+树的Root页定义|

关心下那些我们没猜中:
*  PAGE_LAST_INSERT
    * 最后一条插入的记录地址

* PAGE_DIRECTION
    * 假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边。
    * 用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION。

* PAGE_N_DIRECTION
    * 假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION这个状态表示。
    * 当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。

总结下：此时此刻还是不知道方向有什么卵用，估计后面会学到吧...
    
# File Header
我们来猜猜，如果让你来设计一个通用的 File Header，你会如何设计：
* 页 ID，唯一标识符
* 上一页（按照 innodb 处处是链表的尿性，肯定有个 pre 指针和next指针）
* 下一页
* checksum（校验和，每一页是否完整就靠这个来 check 拉）
* 页类型，这个也可能是索引页、insert buffer 页、inode 页等等

看看答案：

|竞猜结果| 名称	|占用空间大小|	描述|
|----|---|----|----|
|猜中了，果然一个大的数据结构就可能不完整|FIL_PAGE_SPACE_OR_CHKSUM|	4字节	|页的校验和（checksum值）|
|猜中了，我猜的是页 ID，但它好像是个OFFSET | FIL_PAGE_OFFSET	|4字节|	页号|
|猜中了，pre 指针|FIL_PAGE_PREV|	4字节|	上一个页的页号|
|猜中了，next 指针|FIL_PAGE_NEXT|	4字节|	下一个页的页号|
|没想到，这是啥|FIL_PAGE_LSN|	8字节|	页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）|
|猜中了|FIL_PAGE_TYPE|	2字节|	该页的类型|
|没想到，这是啥|FIL_PAGE_FILE_FLUSH_LSN|	8字节|	仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值|
|没想到，这是啥|FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID|	4字节|	页属于哪个表空间|

双指针链表结构示意图如下：
![数据页双指针链表示意图.png](../imgs/mysql/数据页双指针链表示意图.png?raw=true)


# File Trailer
如果我是设计者，如何设计呢？
* checksum 校验和，应该要和 File Header的 checksum 一致才算完整的页

看看答案：

* File Trailer 由 8个字节组成，可以分成2个小部分：
    * 前4个字节代表页的校验和, 这个部分是和File Header中的校验和相对应的。
        * 每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。
        * 如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。
    * 后4个字节代表页面被最后修改时对应的日志序列位置（LSN） 
        * 这个部分也是为了校验页的完整性的，只不过我们目前还没说LSN是个什么意思，所以大家可以先不用管这个属性。
            
看了这个 LSN，在 Header 和 Trailer 都出现了，但是我们依旧不知这是何物，难搞哦！

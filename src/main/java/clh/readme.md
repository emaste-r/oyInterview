# CLH 自旋锁
CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋

我觉得这里的链表应该加上双引号，伪链表吧，毕竟是靠node一个个引用prev+next一个个串起来的，并没有实际上的一个链表。
咦，好像这就是链表，那当我没说，哈。

# 优点1
公平性！说是优点，不如说是特性吧，这是一个公平锁。

# 优点2
空间复杂度低: 
```
如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail
```
# 优点3
而且全在用户态解决并发竞争问题，没有惊动kernel老大，减少了systemCall的损耗。


# 缺点1
一直自旋，并发竞争高时，CPU压力大

# 缺点2
NUMA系统结构不行
```
唯一的缺点是在NUMA系统结构下性能很差，在这种系统结构下，每个线程有自己的内存，如果前趋结点的内存位置比较远，自旋判断前趋结点的locked域，性能将大打折扣，但是在SMP系统结构下该法还是非常有效的。
```
其实上面的说法有点儿不大对，因为每个node的isLock状态都是volatile，都不会用到CPU的 L1,L2,L3缓存，全是去主存里面get，set，所以慢在这里。
